---
draft: false
title: "Non-styled component libraries"
description: "Bring your owns UI design"
date: "2024-07-01"
readingTime: 10
tags:
  - "UI/UX"
  - "Design Systems"
sources:
  - title: "can someone explain in layman terms what is headless UI?"
    url: "https://news.ycombinator.com/item?id=29116806"
    icon: "hackernews.svg"
  - name: "Ariakit"
    title: "Build accessible web apps with React"
    url: "https://ariakit.org/"
    icon: "ariakit.svg"
  # - title: "Headless UI"
  #   url: "https://headlessui.com/"
  #   icon: "headless-ui.svg"
  - title: "React Aria"
    url: "https://react-spectrum.adobe.com/react-aria/"
    icon: "adobe.svg"
  # - title: "Reach UI"
  #   url: "https://reach.tech/"
  #   icon: "reach-ui.svg"
  - title: "So You Think You Can Build A Dropdown?"
    url: "https://www.youtube.com/watch?v=pcMYcjtWwVI"
    icon: "youtube.svg"
---

Imagine your product owner or designer proposes a new feature. A select component where you must be able to select a user and see their avatar and job title.

<Video videoKey="mouse" />

You might hesitate, but the product owner is insistent. They want this component, and they want it now!

Most people would consider one of the following two options:

1. **Using a prebuilt component:**
   1. Use a component library like [Material UI](https://mui.com/) and modify the appearance to match the design.
   2. Use a package like [`react-select`](https://react-select.com/home) to create this component.
2. **Build the component from scratch.**

## Understanding the Problem

Both solutions have their own challenges. Let‚Äôs start with the first approach.

### Using a Prebuilt Component

Most libraries allow customisation through themes. However, like with good ol‚Äô Bootstrap, there are always recognisable elements that are either unmodifiable or very difficult to change.

If you're like me, you often struggle with the library‚Äîoverriding styles with hacky solutions and dealing with missing features in the component API. You strive to create the best user experience, but the component library holds you back.

It's never a good sign when you battle with a library. Component libraries should save time and effort, not increase it.

I gave Material UI a shot to build the mentioned component. Here‚Äôs how it turned out:

<Video videoKey="material" />

<details>
<summary>Expand code</summary>

```tsx
import { useState } from "react";
import { Select, SelectChangeEvent, MenuItem, Avatar, Box } from "@mui/material";
import { styled } from "@mui/material/styles";
import { people } from "./data";

export const CustomSelect = styled(Select<(typeof people)[0]>)(({ theme }) => ({
  fontSize: "0.875rem",
  width: "min(40ch, 100%)",

  "& .MuiInputBase-input": {
    borderRadius: 6,
    backgroundColor: theme.palette.background.paper,
    padding: "0.375rem 0.75rem",
    display: "flex",
    alignItems: "center",
    gap: "0.375rem",
  },
  "& .MuiSelect-icon": {
    display: "none",
  },
}));

export const ListboxMaterial = () => {
  const [selectedPerson, setSelectedPerson] = useState(people[0]);

  const handleOnChange = (event: SelectChangeEvent<(typeof people)[number]>) => {
    const {
      target: { value },
    } = event;

    // On autofill we get a stringified value.
    if (typeof value === "string") return;

    setSelectedPerson(value);
  };

  return (
    <CustomSelect value={selectedPerson} onChange={handleOnChange}>
      {people.map((person) => (
        <MenuItem
          key={person.id}
          id={person.id}
          value={person}
          sx={{
            gap: "0.375rem",
            fontSize: "0.875rem",
          }}
        >
          <Avatar
            sx={{
              marginInlineStart: "-0.25rem",
              width: "2em",
              height: "2em",
            }}
            src={`https://api.dicebear.com/9.x/open-peeps/svg?seed=${person.name}`}
          />
          <span className="name">{person.name}</span>
          <Box
            component="span"
            sx={{
              marginInlineStart: "auto",
              color: (theme) => theme.palette.text.secondary,
              overflow: "hidden",
              textOverflow: "ellipsis",
            }}
          >
            {person.jobTitle}
          </Box>
        </MenuItem>
      ))}
    </CustomSelect>
  );
};
```

While the code is acceptable, I‚Äôm working against the styling of the component, making it harder to maintain.

</details>

---

You can still recognise Material UI, especially the signature ripple effect indicating a user press. We could try to remove these things, but again, we‚Äôd be working against the library.

<aside>
üëâ Depending on the type of application you are building, not having full control over the styling might be beneficial. For internal company applications or proofs of concept, prebuilt libraries can be great. However, for public-facing applications, you probably want more control.

</aside>

Another option is to build the component from scratch.

### Building from Scratch

Alright, so you decide to build the component from scratch. You quickly realize‚Äîor already know‚Äîthat the native [`select`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select) element [falls short in terms of styling](https://stackoverflow.com/questions/1895476/how-do-i-style-a-select-dropdown-with-only-css), so you need to create something custom.

Looking at the component, we need to:

- Show the currently selected option
- Toggle the options list
- Select a new option

Here‚Äôs what I came up with:

<Video videoKey="from-scratch" />

Screen recording of the component.

Pretty neat, right? LGTM. Let‚Äôs ship it!

<details>
<summary>Expand code</summary>

```tsx
import { useState } from "react";
import { people } from "./data";

export const FromScratch = () => {
  const [selectedPerson, setSelectedPerson] = useState(people[0]);
  const [isOpen, setIsOpen] = useState(false);

  const handleToggle = () => {
    setIsOpen(!isOpen);
  };

  const handleSelect = (person: (typeof people)[number]) => {
    setSelectedPerson(person);
    setIsOpen(false);
  };

  return (
    <div className="listbox-wrapper">
      <button className="listbox-value outline" onClick={handleToggle}>
        <img
          className="avatar"
          role="presentation"
          src={`https://api.dicebear.com/9.x/open-peeps/svg?seed=${selectedPerson.name}`}
        />
        <span className="name">{selectedPerson.name}</span>
        <span className="job-title">{selectedPerson.jobTitle}</span>
      </button>
      {isOpen && (
        <div className="listbox-options">
          {people.map((person) => (
            <button
              key={person.id}
              className="listbox-option outline"
              data-selected={person.id === selectedPerson.id || undefined}
              onClick={() => handleSelect(person)}
            >
              <img
                className="avatar"
                role="presentation"
                src={`https://api.dicebear.com/9.x/open-peeps/svg?seed=${person.name}`}
              />
              <span className="name">{person.name}</span>
              <span className="job-title">{person.jobTitle}</span>
            </button>
          ))}
        </div>
      )}
    </div>
  );
};
```

</details>

---

Not so fast! This component is problematic. It tries to mimic the native `select` look with some custom styling, but the native `select` has plenty of functionality we haven‚Äôt considered yet:

- **Keyboard interaction.** In a native `select`, using the arrows will navigate between options. Also you can type to select an option.
- **Focus management.** What happens when we focus away from the options? The select stays open. This is not what we want.
- **ARIA and screen reader support.** We‚Äôve created a select, and visually it looks like a select. But nowhere in the code do we say it is a select.
- **Collision-aware positioning.** By default a select opens on top of the select. But only if there is room on the screen. If there is no more room the position shifts to the top or the bottom depending on where there is space.

Here you can see me trying to click away to close or use the arrow keys to navigate the options. This doesn‚Äôt work. Then, when I try to tab away, I start cycling through the options.

<Video videoKey="nightmare" />

We can try to address all these problems but we would end up with a LOT more code. This component will become a headache to test and maintain.

Building good interaction is really challenging. Users expect a lot from your components, and you need to accommodate a diverse range of users with different preferences and accessibility needs.

Lately I've been using a different approach.

# Headless UI

I love how this name perfectly encapsulates the pattern I‚Äôm discussing. While the term has been around for some time, it‚Äôs now gaining popularity, with an increasing number of libraries adopting this pattern.

Most notably, the similarly named [`@headless-ui/react`](https://headlessui.com/) from Tailwind Labs.

![Comparing headless UI libraries on NPM Trends](/images/npm-trends-headless-ui.png)

**So, _what is it?_**

It‚Äôs _‚ÄúBring your own UI‚Äù_ <sup>[[1]](#sources-1)</sup>. It‚Äôs _‚Äúunstyled primitive components‚Äù_ <sup>[[2]](#sources-2)</sup>.

The key distinction from traditional component libraries is that Headless UI provides the building blocks to create your own components. You have complete control over the design and, most of the time, even the HTML structure.

_‚ÄúWhat does it even do, then?‚Äù_ you might ask.

Well, it kinda depends on the library. But the main themes are:

- Common interaction patterns, not provided by the web platform.
- Cross browser and device compatibility.
- Other.

## Common Interaction Patterns

These are interaction patterns not provided‚Äîor not extensible enough‚Äîby the web platform.

An example is the **Combobox**. This common component is not provided by browsers in any way. People have come to expect this pattern when dealing with large datasets and long lists of options. WIA has described the [Combobox Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/) in detail.

Another good example is the `select` element, which is [famously not stylable.](https://stackoverflow.com/questions/1895476/how-do-i-style-a-select-dropdown-with-only-css) If you want to style a select, we need to implement it ourselves.

<aside>
  üëâÔ∏è There is [some great work](https://open-ui.org/components/selectlist/) being done by the Open UI community on
  breaking down the best way to make a more extensible select element. But in the meantime, if you want to style a
  select, we need to implement it ourselves.
</aside>

---

Alright, so what happens when we try to build that same select component again, but now with `@headless-ui/react`, the most starred Headless UI library from the bunch?

Loading the library and setting up the select (listbox) looks like this:

<Video videoKey="unstyled" />

This might come as a shock, but consider the possibilities here. We don‚Äôt have to find hacky ways to override the default styling of a component because we have control over every HTML element and every line of CSS. For now, we can simply reuse the styles from the ‚Äúbuild from scratch‚Äù example, with some small naming tweaks to align with the components provided by the library.

<Video videoKey="mouse" />

<details>
<summary>Expand code</summary>

```tsx
import { Listbox, ListboxButton, ListboxOption, ListboxOptions } from "@headlessui/react";
import { useState } from "react";
import { people } from "./data";

import "./listbox.headless.css";

export const Headless = () => {
  const [selectedPerson, setSelectedPerson] = useState(people[0]);

  return (
    <Listbox value={selectedPerson} onChange={setSelectedPerson}>
      <ListboxButton className="listbox-button outline">
        <img
          className="avatar"
          role="presentation"
          src={`https://api.dicebear.com/9.x/open-peeps/svg?seed=${selectedPerson.name}`}
        />
        <span className="name">{selectedPerson.name}</span>
        <span className="job-title">{selectedPerson.jobTitle}</span>
      </ListboxButton>
      <ListboxOptions transition unmount={false} anchor={{ to: "bottom", gap: 4 }} className="listbox-options outline">
        {people.map((person) => (
          <ListboxOption key={person.id} value={person} className="listbox-option">
            <img
              className="avatar"
              role="presentation"
              src={`https://api.dicebear.com/9.x/open-peeps/svg?seed=${person.name}`}
            />
            <span className="name">{person.name}</span>
            <span className="job-title">{person.jobTitle}</span>
          </ListboxOption>
        ))}
      </ListboxOptions>
    </Listbox>
  );
};
```

</details>

---

Looking at the code, the end result is pretty similar. We focus mainly on UI elements and business logic. The component remains super readable, but we also gain some additional features.

### **Keyboard interactions**

Using the arrow keys, we can navigate through the options. Using enter, we can select a new option. Escape closes the select and refocuses the `ListboxButton` element.

We can even start searching through the options by typing the first character(s) of an option.

### **Focus management**

There are two focusable areas in this component. First, we have the `ListboxButton` element, which is always visible.

Next, we have the `ListboxOptions` element, which becomes focused upon opening the select. Even when the `ListboxOptions` element is not close to the `ListboxButton` element in the DOM structure, the individual `ListboxOption` elements are not focusable because we can navigate through them using the arrow keys. When the user selects an option, the focus is restored to the `ListboxButton` element.

<Video videoKey="keyboard-navigation-and-focus-management" />

### **ARIA**

ARIA (Accessible Rich Internet Applications) declarations are added. Following the [listbox pattern](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/).

<aside>
üëâ While these libraries help with describing the component using ARIA roles, ensure that custom or hacky solutions maintain correct ARIA roles. *‚ÄúNo ARIA is better than bad ARIA‚Äù.* [3]

</aside>

### Positioning

The default position for the options list is below the currently selected option. If we scroll so the UI element is at the bottom and try to open the options, they are shown above the currently selected option.

<Video videoKey="collision-aware-positioning" />

These are the kinds of features that take time to implement correctly, but they are also what makes a UI great instead of just good.

## Cross browser and device compatibility

The web can be accessed almost anywhere‚Äîdifferent browsers, render engines, devices, and interaction methods.

Our web apps need to function everywhere, preferably with a great experience. Headless UI libraries can help create seamless experiences across different browsers and devices.

I‚Äôll give an example using a simple button. Let‚Äôs say we have an outlined button that inverts its colors when hovered over with a mouse.

<Video videoKey="button-hover" />

<details>
<summary>This is quite easy to do with the `:hover` CSS attribute.</summary>

```css
.button {
  /* Simplified for example */

  color: #326bfb;
  background: transparent;
  border: 1px solid #326bfb;
}

.button:hover {
  color: white;
  background: #326bfb;
}
```

</details>
It looks good, so let's ship it. But wait, let's test it on a mobile device first.

When testing on a real mobile device (not just shrinking the viewport), we might see some strange behavior we didn't expect. The button goes to its hovered state...

‚Ä¶ video here

The web was originally designed around mouse events. When touch devices emerged, browsers added support for touch events but also needed to emulate mouse events to maintain compatibility with existing web apps.

Some Headless UI libraries offer (opinionated) solutions for handling things like hover and focus states making it easier to implement consistent and accessible UI interactions.

<aside>
üëâ For more information on this subject, I highly recommend this blog series about [building a button](https://react-spectrum.adobe.com/blog/building-a-button-part-1.html), which perfectly demonstrates the challenges of creating a seamless experience across different browsers and devices.

</aside>

## Other

I wanted to mention a couple of other headless patterns that do provide functionality but allow you to keep control over styling.

### **Data grids**

Mostly used in administrative systems, these can become fairly complex. With functionality like sorting, filtering, pinning columns, grouping columns etc‚Ä¶

<aside>
üëâ I really recommend [TanStack Table](https://tanstack.com/table/latest/docs/introduction) for this and encourage you to read their motivation/introduction, which also offers a great explanation of headless UI.

</aside>

### **Transitions and Animations**

While CSS can handle this, there are cases where its functionality falls short, such as creating an ‚Äúexit animation‚Äù before a component is unmounted.

From here, we enter the territory of just functionality. Headless UI makes sense if the library is aimed at providing building blocks for the developer.

## Conclusion

Building good interactions is challenging. Users expect a lot from your components, and you need to accommodate a diverse range of users with different preferences and accessibility needs.

So the next time a Product Owner asks you to build a super complex component, consider to use a Headless component library.

> ‚ÄúWait for a second, are you advocating a user interface pattern that doesn't have a user interface?‚Äù
>
> Yes. That is exactly what I'm advocating. <sup>[[4]](#sources-4)</sup>
