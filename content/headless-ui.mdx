---
draft: true
title: "Non-styled component libraries"
description: "Bring your owns UI design"
date: "2024-07-01"
readingTime: 10
tags:
  - "UI/UX"
  - "Design Systems"
sources:
  - title: "can someone explain in layman terms what is headless UI?"
    url: "https://news.ycombinator.com/item?id=29116806"
    icon: "hackernews.svg"
  - name: "Ariakit"
    title: "Build accessible web apps with React"
    url: "https://ariakit.org/"
    icon: "ariakit.svg"
  # - title: "Headless UI"
  #   url: "https://headlessui.com/"
  #   icon: "headless-ui.svg"
  - title: "React Aria"
    url: "https://react-spectrum.adobe.com/react-aria/"
    icon: "adobe.svg"
  # - title: "Reach UI"
  #   url: "https://reach.tech/"
  #   icon: "reach-ui.svg"
  - title: "So You Think You Can Build A Dropdown?"
    url: "https://www.youtube.com/watch?v=pcMYcjtWwVI"
    icon: "youtube.svg"
---

So, what happens when your product owner or designer proposes a feature like this. You must be able to select a user and see their job title.

<Video videoKey="mouse" />

{/* ![A screenshot of a custom dropdown component](/images/custom-dropdown.jpg) */}

You might push back a bit, but the PO is adamant. They want this component, and they want it now!

I‚Äôve this was me a couple of years ago, I would consider the following two options:

1. Using a prebuilt component.
   1. Use a component library like Material UI and modify the appearance to match the design.
   2. Use a package like `react-select` to create this component.
2. Build the component from scratch.

## Understanding the problem

Both of these solutions come with their own set of challenges. Let‚Äôs start with the first approach.

### Using a Component Library

Most libraries allow you to customize their branding using themes. It depends on the library if this works well or not. But much like good ol‚Äô Bootstrap[1], there are always recognisable elements that are either unmodifiable or very difficult to change.

If you're like me, you often find yourself battling the library more than using it‚Äîoverriding styles, dealing with missing features in the component API, etc. You strive to create the best experience for your users, but the component library is holding you back.

It is not a good sign when you are battling with a library. One of the purposes of a Component Library is to safe time and effort. Not to increate time and effort.

But we still need to make the component.. what can we do?

### Building from scratch

Alright, so you decide to build the component from scratch. You quickly realize‚Äîor already know‚Äîthat the native `select` element falls short in terms of styling. Therefore, you need to create something custom.

<Video videoKey="from-scratch" caption="LGTM!" />

<details>
  <summary>Expand code</summary>

```tsx
import { useState } from "react";
import { people } from "./data";

import "./listbox.from-scratch.css";

export const FromScratch = () => {
  const [selectedPerson, setSelectedPerson] = useState(people[0]);
  const [isOpen, setIsOpen] = useState(false);

  const handleToggle = () => {
    setIsOpen(!isOpen);
  };

  const handleSelect = (person: (typeof people)[number]) => {
    setSelectedPerson(person);
    setIsOpen(false);
  };

  return (
    <div className="listbox-wrapper">
      <button className="listbox-value outline" onClick={handleToggle}>
        <img
          className="avatar"
          role="presentation"
          src={`https://api.dicebear.com/9.x/open-peeps/svg?seed=${selectedPerson.name}`}
        />
        <span className="name">{selectedPerson.name}</span>
        <span className="job-title">{selectedPerson.jobTitle}</span>
      </button>
      {isOpen && (
        <div className="listbox-options">
          {people.map((person) => (
            <button
              key={person.id}
              className="listbox-option outline"
              data-selected={person.id === selectedPerson.id || undefined}
              onClick={() => handleSelect(person)}
            >
              <img
                className="avatar"
                role="presentation"
                src={`https://api.dicebear.com/9.x/open-peeps/svg?seed=${person.name}`}
              />
              <span className="name">{person.name}</span>
              <span className="job-title">{person.jobTitle}</span>
            </button>
          ))}
        </div>
      )}
    </div>
  );
};
```

</details>

Okay, when I try to use it, this works. But this code is problematic. We haven‚Äôt considered:

- **Keyboard interaction.** In a native select, using the arrows will navigate between options. Also you can type to select an option.
- **Focus management.** What happens when we focus away from the options? The select stays open. This is not what we want.
- **ARIA and screen reader support.** We‚Äôve created a select, and visually it looks like a select. But nowhere in the code do we say it is a select.
- **Collision-aware positioning.** By default a select opens on top of the select. But only if there is room on the screen. If there is no more room the position shifts to the top or the bottom depending on where there is space.

We can try to address all these problems but we would end up with a LOT more code. This component will become a headache to test and maintain.

Building good interaction is really challenging. Users expect a lot from your components, and you need to accommodate a diverse range of users with different preferences and accessibility needs.
Lately I've been using a different approach.

## Headless UI

I love how this name perfectly encapsulates the pattern I‚Äôm discussing. While the term has been around for some time, it‚Äôs now gaining popularity, with an increasing number of libraries adopting this pattern.

Most notably, the similarly named [`@headless-ui/react`](https://headlessui.com/) from Tailwind Labs.

**_So, what is it?_**

It‚Äôs ‚ÄúBring your own UI‚Äù [<sup>[1]</sup>](#sources-1). It‚Äôs ‚Äúunstyled primitive components‚Äù [<sup>[2]</sup>](#sources-2).

The key distinction from traditional component libraries is that Headless UI provides the building blocks to create your own components. You have complete control over the design and, sometimes, even the HTML structure.

"What does it even do, then?" you might ask.

Well it kinda depends on the library. But the main themes are:

- Common interaction patterns, not provided by the web platform.
- Cross browser and device compatibility.
- Other.

### Common interaction patterns

These are interactions patterns not provided ‚Äì¬†or not extensible enough ‚Äì by the web platform.

An example of such an interaction is the combobox. This is a very common component, but it is not provided by browsers in any way. People have some to expect this pattern when dealing with large datasets and a long list of options. It even has [a official specification](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/).

Another example of a case where browsers are not extensible enough is with the `select` element. This element is famously not stylable. There is [some great work](https://open-ui.org/components/selectlist/) being done by the Open UI community on breaking down the best way to make a more extensible select element. But in the meantime, if you want to style a select, we need to implement it ourselves.

Alright, so what happens when we try to build that same select component again, but now with `@headless-ui/react`. The most starred Headless UI library from the bunch.

From [NPM Trends](https://npmtrends.com/@headlessui/react-vs-@radix-ui/react-dialog-vs-@reach/dialog-vs-ariakit-vs-react-aria-components)

We can re-use the styles from the ‚Äúbuild from scratch‚Äù example. I‚Äôve made some small naming tweaks to be more inline with the components provided by the library.

The end results is kinda similar of even simpler than the version we‚Äôve created from scratch. We are focussing mainly on how the select looks and what elements are there. So the component remains just as readable.

But we also got some more things.

#### Keyboard interactions

Using the arrow keys, we can navigate through the options. Using enter we can select a new option. Escape closes the select and refocusses the `ListboxButton` element.

#### Focus management

There are two focusable areas in this component. First we have the `ListboxButton` element, this is always visible.

Next we have the `ListboxOptions` element. This element will become focused upon opening the select. Even when the `ListboxOptions` element is not close to the `ListboxButton` element when we look at the DOM structure of this component.

The individual ListboxOption elements are not focusable because we can navigate through them using the arrow keys. When the user selects an option, the focus gets restored to the `ListboxButton` element.

#### ARIA

ARIA (Accessible Rich Internet Applications) declarations are added. Following the [listbox specification](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/).

<aside>
‚òù While these libraries will help you with describing the component using ARIA roles. When doing custom stuff with the library, or making ‚Äúhacky‚Äù solutions make sure the ARIA roles are still correct. No ARIA is better than bad ARIA. [2]

</aside>

### Cross browser and device compatibility

The fun thing about the web is that is can be used almost anywhere. There are different browsers, with different render engines. There are a different devices, and different ways of interacting with web content.

And the web apps we write, have to function everywhere. Preferably with a great experience.

So how can headless UI libraries help us here?

They can help us create seamless experiences across different browsers and devices.

<aside>
üëâ If you want to read more about this subject I really recommend this blog series about [building a button](https://react-spectrum.adobe.com/blog/building-a-button-part-1.html) as is perfectly demonstrates the challenges that come with building a seamless experience across different browsers and devices.

</aside>

### Other

I wanted to mention a couple of other headless patterns that do provide functionality but allow you to keep control over styling.

#### Data grids

Mostly used in administrative systems, these can become fairly complex. With functionality like sorting, filtering, pinning columns, grouping columns etc‚Ä¶

<aside>
üëâ I really recommend [TanStack Table](https://tanstack.com/table/latest/docs/introduction) for this and encourage you to read there motivation/introduction as it also has a great explanation about headless UI.

</aside>

#### Transitions and Animations

This can be solved in CSS. But also here, there are use cases where the functionality of CSS falls short. For example, creating an ‚Äúexit animation‚Äù whereafter a component is unmounted.

From here we charter into the territory of just functionality. I think headless UI makes sense if the library is aimed at providing building blocks for the developer.

### Conclusion

If you takeaway one thing from this blogpost. It is this. Create your own if you can do it better. But keep in mind that creating good UI is hard.
